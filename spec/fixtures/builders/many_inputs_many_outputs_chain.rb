#!/usr/bin/env ruby
#
# Creates a 9 block chain, the first 7 aren't very interesting, all coinbase txns.
# 8th block splits up the coinbase output from the 2nd block over 100 txns each with 64 outputs.
# 9th block redeems most of the txns from the 8th by creating 100 txns each w/40 inputs and outputs.
# Unique addresses are used for all outputs in both 8th and 9th blocks.
#
$:.unshift( File.expand_path("../../lib", __FILE__) )
require 'bitcoin'

Bitcoin.network = :testnet3

CHAIN = { main: {}, side: {}, orphan: {} }
WALLET = {}

def current_height(branch=:main); CHAIN[branch].size-1; end
def next_height(branch=:main); current_height(branch) + 1; end
def gen_bip34_height(height); buf = [height].pack("V").gsub(/\x00+$/,""); [buf.bytesize, buf].pack("Ca*"); end

def build_coinbase_tx(next_height, fees=0.0)
  tx = Bitcoin::P::Tx.new
  input = Bitcoin::P::TxIn.new(Bitcoin::P::TxIn::NULL_HASH, Bitcoin::P::TxIn::COINBASE_INDEX, 0, "", Bitcoin::P::TxIn::DEFAULT_SEQUENCE)
  input.script = gen_bip34_height(next_height) + "generated by bitcoin-ruby for testbox"
  tx.inputs << input

  key = Bitcoin::Key.generate
  WALLET[key.addr] = { privkey: key.to_base58 }
  output = Bitcoin::P::TxOut.new(Bitcoin.block_creation_reward(next_height) + fees, Bitcoin::Script.from_string("#{key.pub} OP_CHECKSIG").to_payload)
  tx.outputs << output

  Bitcoin::P::Tx.new(tx.to_payload)
end

def build_next_block(prev_block, next_height, txs=[], time=Time.now.to_i)
  b = Bitcoin::P::Block.new(nil)
  b.prev_block = prev_block ? prev_block.hash.htb.reverse : "\x00"*32
  b.bits = prev_block ? prev_block.bits : Bitcoin.network[:proof_of_work_limit]
  b.ver, b.nonce, b.time = 2, 0, time
  b.tx = [ build_coinbase_tx(next_height, fees=0.0), *txs ]
  b.mrkl_root = Bitcoin.hash_mrkl_tree(b.tx.map(&:hash)).last.htb.reverse

  target = Bitcoin.decode_compact_bits(b.bits).to_i(16)
  b.recalc_block_hash
  until b.hash.to_i(16) < target
    b.nonce += 1
    (b.time += 1; b.nonce = 0) if b.nonce > 0xffffffff
    b.recalc_block_hash
  end

  raise "Payload Error"  unless Bitcoin::P::Block.new(b.to_payload).to_payload == b.to_payload
  b
end

Bitcoin.network[:checkpoints] = {}
Bitcoin.network[:proof_of_work_limit] = Bitcoin.encode_compact_bits("00ffff0000000000000000000000000000000000000000000000000000000000")
Bitcoin.network[:coinbase_maturity] = 5
Bitcoin.network[:retarget_interval] = 126   # 2016
Bitcoin.network[:retarget_time] = 3600      # 1209600
Bitcoin.network[:next_block_time_target] = Bitcoin.network[:retarget_time] / Bitcoin.network[:retarget_interval] # 28 seconds

time = Time.now.to_i - (3600*2) # 2 hours ago

# block 1: genesis block
b = build_next_block(nil, next_height(:main), [], time)
CHAIN[:main][next_height(:main)] = b
Bitcoin.network[:genesis_hash] = b.hash

# blocks 2-7: empty coinbase tx blocks
6.times{
  b = build_next_block(b, next_height(:main), [], time+=Bitcoin.network[:next_block_time_target])
  CHAIN[:main][next_height(:main)] = b
}

# block 8: redeem the output from 2nd block and create 100 transactions with 64 outputs each
num_tx = 100
num_outputs = 64
prev_tx, prev_tx_output_index = CHAIN[:main][1].tx.first, 0
value = prev_tx.outputs[prev_tx_output_index].value
amt_per_addr = value / num_tx / num_outputs

new_txns = []
begin
  new_tx = Bitcoin::Protocol::Tx.new
  new_tx.add_in Bitcoin::Protocol::TxIn.new(prev_tx.binary_hash, prev_tx_output_index, 0)
  begin
    # create all the outputs
    key = Bitcoin::Key.generate
    WALLET[key.addr] = { privkey: key.to_base58 }
    value -= amt_per_addr
    new_tx.add_out Bitcoin::Protocol::TxOut.value_to_address(amt_per_addr, key.addr)
  end while new_tx.out.length < num_outputs
  if value > 0.0
    # send the leftovers somewhere w/the last output
    key = Bitcoin::Key.generate
    WALLET[key.addr] = { privkey: key.to_base58 }
    new_tx.add_out Bitcoin::Protocol::TxOut.value_to_address(value, key.addr)
  end

  input_index = 0
  addr = Bitcoin::Script.new(prev_tx.outputs[prev_tx_output_index].script).get_address
  privkey = WALLET[addr][:privkey]
  key = Bitcoin::Key.from_base58(privkey)
  signature = key.sign(new_tx.signature_hash_for_input(input_index, prev_tx))
  pubkey = new_txns.empty? ? nil : [key.pub].pack("H*") # not needed for coinbase
  new_tx.in[input_index].script_sig = Bitcoin::Script.to_signature_pubkey_script(signature, pubkey)

  new_tx = Bitcoin::Protocol::Tx.new(new_tx.to_payload)
  raise "failed to generate testbox tx #{new_txns.length+1}" unless new_tx.verify_input_signature(input_index, prev_tx) == true
  new_txns << new_tx

  # re-assign these
  prev_tx = new_tx
  prev_tx_output_index = num_outputs

end while new_txns.length < num_tx

b = build_next_block(b, next_height(:main), new_txns, time+=Bitcoin.network[:next_block_time_target])
CHAIN[:main][next_height(:main)] = b

# block 9: redeem most of the small outputs from block 8
redeem_txns = []
begin
  prev_tx = new_txns.shift
  prev_tx_output_index = 0
  new_tx = Bitcoin::Protocol::Tx.new
  begin
    # add previous output as an input
    new_tx.add_in Bitcoin::Protocol::TxIn.new(prev_tx.binary_hash, prev_tx_output_index, 0)
    # create the redeeming output
    key = Bitcoin::Key.generate
    WALLET[key.addr] = { privkey: key.to_base58 }
    new_tx.add_out Bitcoin::Protocol::TxOut.value_to_address(amt_per_addr, key.addr)
    prev_tx_output_index += 1
  end while prev_tx_output_index < (num_outputs - 24) # we can't add them all or we'll exceed max block size

  prev_tx_output_index = 0
  begin
    # sign the inputs
    addr = Bitcoin::Script.new(prev_tx.outputs[prev_tx_output_index].script).get_address
    privkey = WALLET[addr][:privkey]
    key = Bitcoin::Key.from_base58(privkey)
    signature = key.sign(new_tx.signature_hash_for_input(prev_tx_output_index, prev_tx))
    pubkey = [key.pub].pack("H*")
    new_tx.in[prev_tx_output_index].script_sig = Bitcoin::Script.to_signature_pubkey_script(signature, pubkey)
    prev_tx_output_index += 1
  end while prev_tx_output_index < new_tx.inputs.length

  # test
  new_tx = Bitcoin::Protocol::Tx.new(new_tx.to_payload)
  input_index = 0
  while input_index < new_tx.inputs.length do
    if new_tx.verify_input_signature(input_index, prev_tx) != true
      raise "failed to verify input #{input_index} of tx #{redeem_txns.length+1}"
    end
    input_index += 1
  end

  # add this one
  redeem_txns << new_tx

end while !new_txns.empty?

b = build_next_block(b, next_height(:main), redeem_txns, time+=Bitcoin.network[:next_block_time_target])
CHAIN[:main][next_height(:main)] = b

# dump chain and wallet to json
puts JSON.pretty_generate({ chain: CHAIN, wallet: WALLET })
